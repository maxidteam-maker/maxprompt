import { GoogleGenAI, Modality } from "@google/genai";
import { ImageAspectRatio } from '../types';

// Helper function to convert a ReadableStream<Uint8Array> to an ArrayBuffer
async function streamToArrayBuffer(stream: ReadableStream<Uint8Array>): Promise<ArrayBuffer> {
    const reader = stream.getReader();
    const chunks: Uint8Array[] = [];
    while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
    }
    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const buffer = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
        buffer.set(chunk, offset);
        offset += chunk.length;
    }
    return buffer.buffer;
}

// Helper function to convert ArrayBuffer to base64
function arrayBufferToBase64(buffer: ArrayBuffer): string {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}


export async function POST(request: Request) {
  try {
    const apiKey = process.env.API_KEY;
    if (!apiKey) {
      return new Response(JSON.stringify({ error: "API key is not configured on the server" }), { status: 500, headers: { 'Content-Type': 'application/json' } });
    }
    
    const ai = new GoogleGenAI({ apiKey });
    const formData = await request.formData();
    
    const prompt = formData.get('prompt') as string;
    const aspectRatio = formData.get('aspectRatio') as ImageAspectRatio;
    const imageFile = formData.get('image') as File | null;

    // Although prompt is optional for editing, we require it for generation.
    if (!prompt && !imageFile) {
        return new Response(JSON.stringify({ error: "Prompt is required for new image generation" }), { status: 400, headers: { 'Content-Type': 'application/json' } });
    }

    let imageUrl: string;

    if (imageFile) {
        // --- IMAGE EDITING LOGIC (GEMINI) ---
        const imageBuffer = await streamToArrayBuffer(imageFile.stream());
        const imageBase64 = arrayBufferToBase64(imageBuffer);

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [
                    { inlineData: { data: imageBase64, mimeType: imageFile.type } },
                    { text: prompt },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });
        
        const firstPart = response.candidates?.[0]?.content?.parts?.[0];
        if (firstPart && firstPart.inlineData) {
            const base64ImageBytes = firstPart.inlineData.data;
            imageUrl = `data:${firstPart.inlineData.mimeType};base64,${base64ImageBytes}`;
        } else {
            throw new Error("Image editing failed or no image was returned.");
        }
    } else {
        // --- NEW IMAGE GENERATION LOGIC (IMAGEN) ---
        if (!prompt) {
             return new Response(JSON.stringify({ error: "Prompt is required" }), { status: 400, headers: { 'Content-Type': 'application/json' } });
        }
        const response = await ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: prompt,
            config: {
                numberOfImages: 1,
                outputMimeType: 'image/jpeg',
                aspectRatio: aspectRatio,
            },
        });
        
        if (response.generatedImages && response.generatedImages.length > 0) {
            const base64ImageBytes = response.generatedImages[0].image.imageBytes;
            imageUrl = `data:image/jpeg;base64,${base64ImageBytes}`;
        } else {
            throw new Error('No image was generated by Imagen.');
        }
    }

    return new Response(JSON.stringify({ imageUrl }), { status: 200, headers: { 'Content-Type': 'application/json' } });

  } catch (error) {
    console.error("Error in generateImage API:", error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return new Response(JSON.stringify({ error: errorMessage }), { status: 500, headers: { 'Content-Type': 'application/json' } });
  }
}
